name: MaaYYs Resource Build and Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  actions: write

jobs:
  update-and-commit:
    name: Update version and commit
    runs-on: ubuntu-latest
    outputs:
      commit_sha: ${{ steps.commit_push.outputs.commit_sha }}

    steps:
      - name: Checkout MaaYYs repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Update resource_version in config file
        shell: bash
        run: |
          currentTag="${{ github.ref_name }}"
          echo "Updating resource_config.json with version: $currentTag"
          python3 -c "import json; config_path = 'resource_config.json'; f = open(config_path, 'r+'); config = json.load(f); config['resource_version'] = '$currentTag'; f.seek(0); f.truncate(); json.dump(config, f, indent=2, ensure_ascii=False)"
          echo "resource_config.json updated successfully:"
          cat resource_config.json

      - name: Commit and Push changes
        id: commit_push
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          if ! git diff --quiet resource_config.json; then
            echo "Changes detected. Committing and pushing..."
            git add resource_config.json
            git commit -m "ci: Update resource_version to ${{ github.ref_name }}" -m "[skip ci]"
            DEFAULT_BRANCH=${{ github.event.repository.default_branch }}
            echo "Pushing changes to default branch: $DEFAULT_BRANCH"
            git push origin HEAD:$DEFAULT_BRANCH
          else
            echo "No changes to commit."
          fi

          NEW_COMMIT_SHA=$(git rev-parse HEAD)
          echo "New commit SHA: $NEW_COMMIT_SHA"
          echo "commit_sha=${NEW_COMMIT_SHA}" >> $GITHUB_OUTPUT

  build:
    name: Build ${{ matrix.os }}
    needs: update-and-commit
    runs-on: ${{ matrix.runner }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-x64
            runner: windows-latest
            mfwph_pattern: 'MFWPH_windows-x64.zip'
            archive_extension: '.zip'
          - os: macos-x64
            runner: macos-13
            mfwph_pattern: 'MFWPH_macos-x64.tar.gz'
            archive_extension: '.tar.gz'
          - os: macos-arm64
            runner: macos-14
            mfwph_pattern: 'MFWPH_macos-arm64.tar.gz'
            archive_extension: '.tar.gz'
          - os: linux-x64
            runner: ubuntu-latest
            mfwph_pattern: 'MFWPH_linux-x64.tar.gz'
            archive_extension: '.tar.gz'

    steps:
      - name: Checkout MaaYYs repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.update-and-commit.outputs.commit_sha }}
          path: MaaYYs
          fetch-depth: 0

      - name: Set up Python (Unix)
        if: runner.os != 'Windows'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      # 注意：这里的Changelog生成只是为了给build job内部使用（如果需要的话）
      # release job会独立重新生成一次，所以这里的逻辑暂时保留，但最终发布以release job为准
      - name: Generate Changelog (Windows)
        if: runner.os == 'Windows'
        id: changelog_windows
        shell: pwsh
        working-directory: MaaYYs
        run: |
          $currentTag = "${{ github.ref_name }}"
          # 使用修正后的逻辑
          $previousTag = git describe --tags --abbrev=0 "${{ github.ref_name }}^" 2>$null
          if (-not $previousTag) {
            $previousTag = git rev-list --max-parents=0 HEAD
          }
          $changelog = git log --pretty=format:"* %s (%h)" "$previousTag..$currentTag"
          if (-not $changelog) {
            $changelog = "* 首次发布"
          }
          $changelog = $changelog -replace "`n", "%0A"
          "CHANGELOG<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          $changelog | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Generate Changelog (Unix)
        if: runner.os != 'Windows'
        id: changelog_unix
        shell: bash
        working-directory: MaaYYs
        run: |
          CURRENT_TAG="${{ github.ref_name }}"
          # 使用修正后的逻辑
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 "${{ github.ref_name }}^" 2>/dev/null || git rev-list --max-parents=0 HEAD)
          CHANGELOG=$(git log --pretty=format:"* %s (%h)" "$PREVIOUS_TAG..$CURRENT_TAG")
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="* 首次发布"
          fi
          {
            echo 'CHANGELOG<<EOF'
            echo "$CHANGELOG"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Fetch latest MFWPH release (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # 创建下载目录
          New-Item -Path "mfwph-download" -ItemType Directory -Force
          
          # 获取最新的MFWPH发布版本 (使用 GITHUB_TOKEN 进行认证以避免频率限制)
          Write-Host "Fetching latest MFWPH release..."
          $headers = @{ "Authorization" = "Bearer ${{ secrets.GITHUB_TOKEN }}" }
          $release = Invoke-RestMethod -Uri "https://api.github.com/repos/TanyaShue/MFWPH/releases/latest" -Headers $headers
          
          # 查找对应平台的下载URL
          $downloadUrl = ($release.assets | Where-Object { $_.name -eq "${{ matrix.mfwph_pattern }}" }).browser_download_url
          
          if (-not $downloadUrl) {
            Write-Host "::error::Could not find ${{ matrix.mfwph_pattern }} in the latest release"
            exit 1
          }
          
          Write-Host "Downloading MFWPH from: $downloadUrl"
          
          # 增加重试逻辑
          $retryCount = 3
          $retryDelay = 5 # seconds
          for ($i=1; $i -le $retryCount; $i++) {
            try {
              Write-Host "Download attempt $i of $retryCount..."
              Invoke-WebRequest -Uri $downloadUrl -OutFile "mfwph-download/${{ matrix.mfwph_pattern }}"
              Write-Host "Download successful."
              break # 成功后退出循环
            } catch {
              Write-Host "::warning::Download failed on attempt $i. Error: $_"
              if ($i -lt $retryCount) {
                Write-Host "Retrying in $retryDelay seconds..."
                Start-Sleep -Seconds $retryDelay
              } else {
                Write-Host "::error::Failed to download after $retryCount attempts."
                exit 1
              }
            }
          }
          
          # 解压MFWPH
          Expand-Archive -Path "mfwph-download/${{ matrix.mfwph_pattern }}" -DestinationPath "mfwph-extracted" -Force
          Write-Host "MFWPH package extracted successfully"

      - name: Fetch latest MFWPH release (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          # 创建下载目录
          mkdir -p mfwph-download
          
          # 获取最新的MFWPH发布版本 (使用 GITHUB_TOKEN 进行认证以避免频率限制)
          echo "Fetching latest MFWPH release..."
          RELEASE_JSON=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/repos/TanyaShue/MFWPH/releases/latest)
          
          # 查找对应平台的下载URL
          DOWNLOAD_URL=$(echo "$RELEASE_JSON" | python3 -c "import sys, json; data = json.load(sys.stdin); pattern = '${{ matrix.mfwph_pattern }}'; [print(asset['browser_download_url']) for asset in data.get('assets', []) if asset['name'] == pattern]" | head -n1)
          
          if [ -z "$DOWNLOAD_URL" ]; then
            echo "::error::Could not find ${{ matrix.mfwph_pattern }} in the latest release"
            echo "Available assets:"
            echo "$RELEASE_JSON" | python3 -c "import sys, json; data = json.load(sys.stdin); [print(asset['name']) for asset in data.get('assets', [])]"
            exit 1
          fi
          
          echo "Downloading MFWPH from: $DOWNLOAD_URL"

          # 增加重试逻辑
          retry_count=3
          retry_delay=5 # seconds
          for i in $(seq 1 $retry_count); do
            echo "Download attempt $i of $retry_count..."
            # 使用 -L 跟踪重定向, --fail 在HTTP错误时失败
            curl -L --fail -o "mfwph-download/${{ matrix.mfwph_pattern }}" "$DOWNLOAD_URL"
            if [ $? -eq 0 ]; then
              echo "Download successful."
              break # 成功后退出循环
            fi

            if [ $i -lt $retry_count ]; then
              echo "::warning::Download failed. Retrying in $retry_delay seconds..."
              sleep $retry_delay
            else
              echo "::error::Failed to download after $retry_count attempts."
              exit 1
            fi
          done
          
          # 创建解压目录并解压
          mkdir -p mfwph-extracted
          tar -xzf "mfwph-download/${{ matrix.mfwph_pattern }}" -C mfwph-extracted
          
          # 检查解压后的内容
          echo "Extracted contents:"
          ls -la mfwph-extracted/
          
          # 如果解压后有一个MFWPH子目录，将其内容移到上一级
          if [ -d "mfwph-extracted/MFWPH" ]; then
            echo "Moving MFWPH contents up one level..."
            mv mfwph-extracted/MFWPH/* mfwph-extracted/ 2>/dev/null || true
            mv mfwph-extracted/MFWPH/.* mfwph-extracted/ 2>/dev/null || true
            rmdir mfwph-extracted/MFWPH 2>/dev/null || true
          fi
          
          echo "Final structure:"
          ls -la mfwph-extracted/
          echo "MFWPH package extracted successfully"

      - name: Prepare resource directory (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # 定义要排除的文件和文件夹列表
          $excludeList = @('.git', '.github', '.idea', '.gitignore', '.gitattributes', 'debug', 'dist', 'mfwph-download', 'mfwph-extracted', 'resources-temp')
          
          # 确保资源目录存在
          New-Item -Path "mfwph-extracted/assets/resource/MaaYYs" -ItemType Directory -Force
          
          # 清空目标资源目录（如果存在）
          if (Test-Path -Path "mfwph-extracted/assets/resource/MaaYYs") {
            Get-ChildItem -Path "mfwph-extracted/assets/resource/MaaYYs" | Remove-Item -Recurse -Force
          }
          
          # 获取源目录中的所有文件和文件夹
          $allItems = Get-ChildItem -Path "MaaYYs" -Force
          
          # 复制不在排除列表中的所有文件和文件夹
          foreach ($item in $allItems) {
            $itemName = $item.Name
            if ($excludeList -notcontains $itemName) {
              if (Test-Path -Path $item.FullName -PathType Container) {
                # 如果是目录，则递归复制
                New-Item -Path "mfwph-extracted/assets/resource/MaaYYs/$itemName" -ItemType Directory -Force
                Copy-Item -Path "$($item.FullName)/*" -Destination "mfwph-extracted/assets/resource/MaaYYs/$itemName" -Recurse -Force
                Write-Host "Copied directory $itemName to resource directory"
              } else {
                # 如果是文件，则直接复制
                Copy-Item -Path $item.FullName -Destination "mfwph-extracted/assets/resource/MaaYYs/$itemName" -Force
                Write-Host "Copied file $itemName to resource directory"
              }
            } else {
              Write-Host "Excluded $itemName from resource directory"
            }
          }
          Write-Host "Resources copied successfully to MFWPH package"

      - name: Prepare resource directory (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          # 定义要排除的文件和文件夹列表
          EXCLUDE_LIST=".git .github .idea .gitignore .gitattributes debug dist mfwph-download mfwph-extracted resources-temp"
          
          # 确保mfwph-extracted是目录
          if [ ! -d "mfwph-extracted" ]; then
            echo "Error: mfwph-extracted is not a directory"
            ls -la
            exit 1
          fi
          
          # 确保资源目录存在
          mkdir -p "mfwph-extracted/assets/resource/MaaYYs"
          
          # 清空目标资源目录（如果存在内容）
          if [ -d "mfwph-extracted/assets/resource/MaaYYs" ]; then
            rm -rf "mfwph-extracted/assets/resource/MaaYYs"/*
          fi
          
          # 复制资源文件（排除不需要的）
          for item in MaaYYs/*; do
            basename_item=$(basename "$item")
            skip=false
            for exclude in $EXCLUDE_LIST; do
              if [ "$basename_item" = "$exclude" ]; then
                skip=true
                echo "Excluded $basename_item from resource directory"
                break
              fi
            done
            
            if [ "$skip" = false ]; then
              cp -r "$item" "mfwph-extracted/assets/resource/MaaYYs/"
              echo "Copied $basename_item to resource directory"
            fi
          done
          
          # 复制隐藏文件（如果需要）
          shopt -s dotglob 2>/dev/null || true
          for item in MaaYYs/.*; do
            basename_item=$(basename "$item")
            if [ "$basename_item" != "." ] && [ "$basename_item" != ".." ]; then
              skip=false
              for exclude in $EXCLUDE_LIST; do
                if [ "$basename_item" = "$exclude" ]; then
                  skip=true
                  break
                fi
              done
              
              if [ "$skip" = false ]; then
                cp -r "$item" "mfwph-extracted/assets/resource/MaaYYs/" 2>/dev/null || true
              fi
            fi
          done
          
          echo "Resources copied successfully to MFWPH package"

      - name: Create full package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # 创建输出目录
          New-Item -Path "dist" -ItemType Directory -Force
          
          # 创建ZIP包
          Compress-Archive -Path "mfwph-extracted/*" -DestinationPath "${{ github.workspace }}/dist/MAA_YYS_FULL_${{ matrix.os }}.zip" -Force
          
          Write-Host "Created full package: MAA_YYS_FULL_${{ matrix.os }}.zip"

      - name: Create full package (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          # 创建输出目录
          mkdir -p dist
          
          # 检查mfwph-extracted目录
          if [ ! -d "mfwph-extracted" ]; then
            echo "Error: mfwph-extracted directory not found"
            ls -la
            exit 1
          fi
          
          # 创建tar.gz包
          echo "Creating archive from mfwph-extracted directory..."
          (cd mfwph-extracted && tar -czf "${{ github.workspace }}/dist/MAA_YYS_FULL_${{ matrix.os }}.tar.gz" .)
          
          echo "Created full package: MAA_YYS_FULL_${{ matrix.os }}.tar.gz"
          ls -lh dist/

      - name: Create resources-only package (Windows only)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # 定义要包含的文件和文件夹列表
          $includeList = @('app','resource_pack', 'custom_dir', 'image', 'model', 'pipeline', 'LICENSE', 'README.md','doc', 'resource_config.json')
          
          # 创建临时目录用于资源包
          New-Item -Path "resources-temp" -ItemType Directory -Force
          
          # 仅复制包含列表中的文件和文件夹到临时目录
          foreach ($item in $includeList) {
            $sourcePath = "MaaYYs/$item"
            if (Test-Path -Path $sourcePath) {
              if (Test-Path -Path $sourcePath -PathType Container) {
                # 如果是目录，则递归复制
                Copy-Item -Path $sourcePath -Destination "resources-temp/" -Recurse -Force
              } else {
                # 如果是文件，则直接复制
                Copy-Item -Path $sourcePath -Destination "resources-temp/" -Force
              }
              Write-Host "Copied $item to resources-only package"
            } else {
              Write-Host "Warning: $item not found in source repository for resources-only package"
            }
          }
          
          # 创建仅包含资源的ZIP文件
          Compress-Archive -Path "resources-temp/*" -DestinationPath "${{ github.workspace }}/dist/MAA_YYS_RESOURCES_ONLY.zip" -Force
          
          Write-Host "Created resources-only package: MAA_YYS_RESOURCES_ONLY.zip"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-build
          path: dist/*
          retention-days: 7

  release:
    name: Create Release
    needs: [build, update-and-commit]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.update-and-commit.outputs.commit_sha }}
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Generate Changelog
        id: changelog
        run: |
          CURRENT_TAG="${{ github.ref_name }}"
          # ================== 此处是关键修正 ==================
          # 直接基于当前标签的父提交来查找上一个标签
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 "${{ github.ref_name }}^" 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Current tag: $CURRENT_TAG"
          echo "Previous tag: $PREVIOUS_TAG"
          
          # 这个命令的范围现在是正确的 <PREVIOUS_TAG>...<CURRENT_TAG>
          CHANGELOG=$(git log --pretty=format:"* %s (%h)" "$PREVIOUS_TAG..$CURRENT_TAG")
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="* 首次发布"
          fi
          {
            echo 'CHANGELOG<<EOF'
            echo "$CHANGELOG"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Prepare release files
        run: |
          mkdir -p release_files
          find ./artifacts -type f \( -name "*.zip" -o -name "*.tar.gz" \) \
            -exec mv {} ./release_files/ \;
          echo "Release files:"
          ls -la ./release_files/

      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          body: |
            ## 版本 ${{ github.ref_name }} 更新日志
            
            ${{ steps.changelog.outputs.CHANGELOG }}
            
            [已有 Mirror酱 CDK？点击前往高速下载](https://mirrorchyan.com/zh/projects?rid=MaaYYs)
          draft: false
          prerelease: false
          artifacts: ./release_files/*
          artifactContentType: application/octet-stream
          artifactErrorsFailBuild: true

      - name: Trigger MirrorChyanUploading
        shell: bash
        run: |
          gh workflow run --repo $GITHUB_REPOSITORY mirrorchyan
          gh workflow run --repo $GITHUB_REPOSITORY mirrorchyan_release_note
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}